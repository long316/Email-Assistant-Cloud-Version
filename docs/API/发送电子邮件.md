# 发送电子邮件

您可以通过两种方式使用 Gmail API 发送电子邮件：

- 您可以使用 [`messages.send`](https://developers.google.com/workspace/gmail/api/v1/reference/users/messages/send?hl=zh-cn) 方法直接发送。
- 您可以使用 [`drafts.send`](https://developers.google.com/workspace/gmail/api/v1/reference/users/drafts/send?hl=zh-cn) 方法从草稿中发送电子邮件。

电子邮件以 base64url 编码的字符串形式在[消息资源](https://developers.google.com/workspace/gmail/api/v1/reference/users/messages?hl=zh-cn)的 `raw` 属性中发送。发送电子邮件的总体工作流程如下：

1. 以某种便捷的方式创建电子邮件内容，并将其编码为 base64url 字符串。
2. 创建新的消息资源，并将其 `raw` 属性设置为您刚刚创建的 base64url 字符串。
3. 调用 `messages.send`，或者，如果发送的是草稿，则调用 `drafts.send` 来发送消息。

此工作流程的详细信息可能会因您选择的客户端库和编程语言而异。

## 创建消息

Gmail API 需要符合 [RFC 2822](https://tools.ietf.org/html/rfc2822) 且编码为 base64url 字符串的 MIME 电子邮件。许多编程语言都有库或实用程序，可简化创建和编码 MIME 消息的过程。以下代码示例演示了如何使用适用于各种语言的 Google API 客户端库创建 MIME 消息。

[Java](https://developers.google.com/workspace/gmail/api/guides/sending?hl=zh-cn#java)[Python](https://developers.google.com/workspace/gmail/api/guides/sending?hl=zh-cn#python)

以下代码示例演示了如何创建 MIME 消息、将其编码为 base64url 字符串，并将其分配给 `Message` 资源的 `raw` 字段：

gmail/snippet/send mail/create_draft.py

[在 GitHub 上查看](https://github.com/googleworkspace/python-samples/blob/main/gmail/snippet/send mail/create_draft.py)

```
import base64
from email.message import EmailMessage

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_create_draft():
  """Create and insert a draft email.
   Print the returned draft's message and id.
   Returns: Draft object, including draft id and message meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)

    message = EmailMessage()

    message.set_content("This is automated draft mail")

    message["To"] = "gduser1@workspacesamples.dev"
    message["From"] = "gduser2@workspacesamples.dev"
    message["Subject"] = "Automated draft"

    # encoded message
    encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    create_message = {"message": {"raw": encoded_message}}
    # pylint: disable=E1101
    draft = (
        service.users()
        .drafts()
        .create(userId="me", body=create_message)
        .execute()
    )

    print(f'Draft id: {draft["id"]}\nDraft message: {draft["message"]}')

  except HttpError as error:
    print(f"An error occurred: {error}")
    draft = None

  return draft


if __name__ == "__main__":
  gmail_create_draft()
```

## 创建包含附件的消息

创建含附件的消息与创建任何其他消息类似，但将文件作为多部分 MIME 消息上传的过程取决于编程语言。以下代码示例演示了创建包含附件的多部分 MIME 消息的可能方式。

[Java](https://developers.google.com/workspace/gmail/api/guides/sending?hl=zh-cn#java)[Python](https://developers.google.com/workspace/gmail/api/guides/sending?hl=zh-cn#python)

与上一个示例类似，此示例也会处理将消息编码为 base64url 并将其分配给 `Message` 资源的 `raw` 字段。

gmail/snippet/send mail/create_draft_with_attachment.py

[在 GitHub 上查看](https://github.com/googleworkspace/python-samples/blob/main/gmail/snippet/send mail/create_draft_with_attachment.py)

```
import base64
import mimetypes
import os
from email.message import EmailMessage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.text import MIMEText

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_create_draft_with_attachment():
  """Create and insert a draft email with attachment.
   Print the returned draft's message and id.
  Returns: Draft object, including draft id and message meta data.

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    # create gmail api client
    service = build("gmail", "v1", credentials=creds)
    mime_message = EmailMessage()

    # headers
    mime_message["To"] = "gduser1@workspacesamples.dev"
    mime_message["From"] = "gduser2@workspacesamples.dev"
    mime_message["Subject"] = "sample with attachment"

    # text
    mime_message.set_content(
        "Hi, this is automated mail with attachment.Please do not reply."
    )

    # attachment
    attachment_filename = "photo.jpg"
    # guessing the MIME type
    type_subtype, _ = mimetypes.guess_type(attachment_filename)
    maintype, subtype = type_subtype.split("/")

    with open(attachment_filename, "rb") as fp:
      attachment_data = fp.read()
    mime_message.add_attachment(attachment_data, maintype, subtype)

    encoded_message = base64.urlsafe_b64encode(mime_message.as_bytes()).decode()

    create_draft_request_body = {"message": {"raw": encoded_message}}
    # pylint: disable=E1101
    draft = (
        service.users()
        .drafts()
        .create(userId="me", body=create_draft_request_body)
        .execute()
    )
    print(f'Draft id: {draft["id"]}\nDraft message: {draft["message"]}')
  except HttpError as error:
    print(f"An error occurred: {error}")
    draft = None
  return draft


def build_file_part(file):
  """Creates a MIME part for a file.

  Args:
    file: The path to the file to be attached.

  Returns:
    A MIME part that can be attached to a message.
  """
  content_type, encoding = mimetypes.guess_type(file)

  if content_type is None or encoding is not None:
    content_type = "application/octet-stream"
  main_type, sub_type = content_type.split("/", 1)
  if main_type == "text":
    with open(file, "rb"):
      msg = MIMEText("r", _subtype=sub_type)
  elif main_type == "image":
    with open(file, "rb"):
      msg = MIMEImage("r", _subtype=sub_type)
  elif main_type == "audio":
    with open(file, "rb"):
      msg = MIMEAudio("r", _subtype=sub_type)
  else:
    with open(file, "rb"):
      msg = MIMEBase(main_type, sub_type)
      msg.set_payload(file.read())
  filename = os.path.basename(file)
  msg.add_header("Content-Disposition", "attachment", filename=filename)
  return msg


if __name__ == "__main__":
  gmail_create_draft_with_attachment()
```

## 发送消息

创建消息后，您可以在对 [`messages.send`](https://developers.google.com/workspace/gmail/api/v1/reference/users/messages/send?hl=zh-cn) 的调用的请求正文中提供该消息，从而发送该消息，如以下示例所示。

[Java](https://developers.google.com/workspace/gmail/api/guides/sending?hl=zh-cn#java)[Python](https://developers.google.com/workspace/gmail/api/guides/sending?hl=zh-cn#python)

gmail/snippet/send mail/send_message.py

[在 GitHub 上查看](https://github.com/googleworkspace/python-samples/blob/main/gmail/snippet/send mail/send_message.py)

```
import base64
from email.message import EmailMessage

import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


def gmail_send_message():
  """Create and send an email message
  Print the returned  message id
  Returns: Message object, including message id

  Load pre-authorized user credentials from the environment.
  TODO(developer) - See https://developers.google.com/identity
  for guides on implementing OAuth2 for the application.
  """
  creds, _ = google.auth.default()

  try:
    service = build("gmail", "v1", credentials=creds)
    message = EmailMessage()

    message.set_content("This is automated draft mail")

    message["To"] = "gduser1@workspacesamples.dev"
    message["From"] = "gduser2@workspacesamples.dev"
    message["Subject"] = "Automated draft"

    # encoded message
    encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    create_message = {"raw": encoded_message}
    # pylint: disable=E1101
    send_message = (
        service.users()
        .messages()
        .send(userId="me", body=create_message)
        .execute()
    )
    print(f'Message Id: {send_message["id"]}')
  except HttpError as error:
    print(f"An error occurred: {error}")
    send_message = None
  return send_message


if __name__ == "__main__":
  gmail_send_message()
```

如果您尝试发送回复，并希望电子邮件形成会话，请确保：

1. `Subject` 标头匹配
2. `References` 和 `In-Reply-To` 标头遵循 [RFC 2822](https://tools.ietf.org/html/rfc2822#appendix-A.2) 标准。

如需了解如何从草稿发送消息，请参阅[创建草稿](https://developers.google.com/workspace/gmail/api/guides/drafts?hl=zh-cn)。